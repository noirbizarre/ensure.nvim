local util = require("ensure.util")

describe("ensure.util", function()
    describe("Queue", function()
        local Queue = util.Queue

        describe("new", function()
            it("creates an empty queue", function()
                local q = Queue:new()
                assert.is_true(q:is_empty())
            end)

            it("has correct initial state", function()
                local q = Queue:new()
                assert.equals(q.position, 0)
                assert.same(q.items, {})
            end)
        end)

        describe("enqueue", function()
            it("adds a single item", function()
                local q = Queue:new()
                q:enqueue("item1")
                assert.is_false(q:is_empty())
            end)

            it("adds multiple items in sequence", function()
                local q = Queue:new()
                q:enqueue("a")
                q:enqueue("b")
                q:enqueue("c")
                assert.equals(q.position, 0)
                assert.are.same(q.items, { "a", "b", "c" })
            end)

            it("handles different types", function()
                local q = Queue:new()
                q:enqueue("string")
                q:enqueue(42)
                q:enqueue({ key = "value" })
                assert.are.same(q.items, { "string", 42, { key = "value" } })
            end)
        end)

        describe("dequeue", function()
            it("returns nil for empty queue", function()
                local q = Queue:new()
                assert.is_nil(q:dequeue())
            end)

            it("returns items in FIFO order", function()
                local q = Queue:new()
                q:enqueue("first")
                q:enqueue("second")
                q:enqueue("third")

                assert.equals("first", q:dequeue())
                assert.equals("second", q:dequeue())
                assert.equals("third", q:dequeue())
            end)

            it("returns nil after all items dequeued", function()
                local q = Queue:new()
                q:enqueue("only")
                q:dequeue()
                assert.is_nil(q:dequeue())
            end)

            it("handles interleaved enqueue and dequeue", function()
                local q = Queue:new()
                q:enqueue("a")
                q:enqueue("b")
                assert.equals("a", q:dequeue())
                q:enqueue("c")
                assert.equals("b", q:dequeue())
                assert.equals("c", q:dequeue())
                assert.is_nil(q:dequeue())
            end)
        end)

        describe("size", function()
            it("returns 0 for new queue", function()
                local q = Queue:new()
                assert.equals(0, q:size())
            end)

            it("returns correct size after enqueues", function()
                local q = Queue:new()
                q:enqueue("a")
                q:enqueue("b")
                assert.equals(2, q:size())
            end)

            it("returns correct size after dequeues", function()
                local q = Queue:new()
                q:enqueue("a")
                q:enqueue("b")
                q:dequeue()
                assert.equals(1, q:size())
            end)

            it("returns 0 after all items dequeued", function()
                local q = Queue:new()
                q:enqueue("a")
                q:dequeue()
                assert.equals(0, q:size())
            end)
        end)

        describe("is_empty", function()
            it("returns true for new queue", function()
                local q = Queue:new()
                assert.is_true(q:is_empty())
            end)

            it("returns false after enqueue", function()
                local q = Queue:new()
                q:enqueue("item")
                assert.is_false(q:is_empty())
            end)

            it("returns true after all items dequeued", function()
                local q = Queue:new()
                q:enqueue("a")
                q:enqueue("b")
                q:dequeue()
                q:dequeue()
                assert.is_true(q:is_empty())
            end)
        end)

        describe("seen", function()
            it("returns false for empty queue", function()
                local q = Queue:new()
                assert.is_false(q:seen("missing"))
            end)

            it("returns true for item in queue", function()
                local q = Queue:new()
                q:enqueue("exists")
                assert.is_true(q:seen("exists"))
            end)

            it("returns false for item not in queue", function()
                local q = Queue:new()
                q:enqueue("exists")
                assert.is_false(q:seen("missing"))
            end)

            it("returns true for item that was dequeued", function()
                local q = Queue:new()
                q:enqueue("was_here")
                q:dequeue()
                assert.is_true(q:seen("was_here"))
            end)

            it("tracks all items ever enqueued", function()
                local q = Queue:new()
                q:enqueue("a")
                q:enqueue("b")
                q:dequeue()
                q:enqueue("c")
                q:dequeue()
                q:dequeue()

                assert.is_true(q:seen("a"))
                assert.is_true(q:seen("b"))
                assert.is_true(q:seen("c"))
                assert.is_false(q:seen("never_added"))
            end)
        end)

        describe("clear", function()
            it("resets an empty queue", function()
                local q = Queue:new()
                q:clear()
                assert.is_true(q:is_empty())
            end)

            it("clears a non-empty queue", function()
                local q = Queue:new()
                q:enqueue("item1")
                q:enqueue("item2")
                q:clear()
                assert.is_true(q:is_empty())
            end)

            it("allows reuse after clear", function()
                local q = Queue:new()
                q:enqueue("item")
                q:clear()
                q:enqueue("new_item")
                assert.equals("new_item", q:dequeue())
                assert.is_nil(q:dequeue())
            end)
        end)
    end)

    describe("string_list", function()
        it("wraps string into list", function()
            local result = util.string_list("foo")
            assert.same({ "foo" }, result)
        end)

        it("returns table as is", function()
            local value = { "foo", "bar" }
            local result = util.string_list(value)
            assert.same(value, result)
        end)

        it("handles empty table", function()
            local result = util.string_list({})
            assert.same({}, result)
        end)
    end)

    describe("split_filetypes", function()
        it("returns empty table for nil", function()
            local result = util.split_filetypes(nil)
            assert.same({}, result)
        end)

        it("returns empty table for empty string", function()
            local result = util.split_filetypes("")
            assert.same({}, result)
        end)

        it("returns single filetype as single-element table", function()
            local result = util.split_filetypes("lua")
            assert.same({ "lua" }, result)
        end)

        it("splits compound filetype into parts", function()
            local result = util.split_filetypes("html.handlebars")
            assert.same({ "html", "handlebars" }, result)
        end)

        it("handles multiple dots in compound filetype", function()
            local result = util.split_filetypes("a.b.c")
            assert.same({ "a", "b", "c" }, result)
        end)

        it("handles real-world compound filetypes", function()
            assert.same({ "html", "jinja" }, util.split_filetypes("html.jinja"))
            assert.same({ "javascript", "jsx" }, util.split_filetypes("javascript.jsx"))
            assert.same({ "c", "doxygen" }, util.split_filetypes("c.doxygen"))
        end)
    end)
end)
